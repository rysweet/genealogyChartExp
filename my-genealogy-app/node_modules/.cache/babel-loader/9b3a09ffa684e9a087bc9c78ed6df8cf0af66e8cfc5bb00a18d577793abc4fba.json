{"ast":null,"code":"export function exportGedcom(people) {\n  let gedcomText = \"0 HEAD\\n1 CHAR UTF-8\\n\";\n\n  // Create map of people by ID for easy lookup\n  const peopleById = new Map(people.map(p => [p.id, p]));\n\n  // First export all INDI records\n  people.forEach((person, index) => {\n    gedcomText += `0 @${person.id}@ INDI\\n`;\n    gedcomText += `1 NAME ${person.firstName || \"\"} /${person.lastName || \"\"}/\\n`;\n    if (person.birthDate) {\n      gedcomText += \"1 BIRT\\n2 DATE \" + person.birthDate + \"\\n\";\n    }\n    if (person.deathDate) {\n      gedcomText += \"1 DEAT\\n2 DATE \" + person.deathDate + \"\\n\";\n    }\n  });\n\n  // Then create FAM records based on parent relationships\n  const processedFamilies = new Set();\n  people.forEach(person => {\n    if (person.parents && person.parents.length > 0) {\n      // Create a unique family ID based on parents\n      const familyId = `F${person.parents.sort().join('_')}`;\n\n      // Only process each family once\n      if (!processedFamilies.has(familyId)) {\n        processedFamilies.add(familyId);\n        gedcomText += `0 @${familyId}@ FAM\\n`;\n        if (person.parents[0]) {\n          gedcomText += `1 HUSB @${person.parents[0]}@\\n`;\n        }\n        if (person.parents[1]) {\n          gedcomText += `1 WIFE @${person.parents[1]}@\\n`;\n        }\n\n        // Find all children who share these parents\n        people.forEach(potentialChild => {\n          if (potentialChild.parents && potentialChild.parents.length === person.parents.length && potentialChild.parents.every(p => person.parents.includes(p))) {\n            gedcomText += `1 CHIL @${potentialChild.id}@\\n`;\n          }\n        });\n      }\n    }\n  });\n  gedcomText += \"0 TRLR\\n\";\n  return gedcomText;\n}","map":{"version":3,"names":["exportGedcom","people","gedcomText","peopleById","Map","map","p","id","forEach","person","index","firstName","lastName","birthDate","deathDate","processedFamilies","Set","parents","length","familyId","sort","join","has","add","potentialChild","every","includes"],"sources":["/Users/ryan/genealogyChartExp/my-genealogy-app/src/gedcom/exportGedcom.js"],"sourcesContent":["export function exportGedcom(people) {\n  let gedcomText = \"0 HEAD\\n1 CHAR UTF-8\\n\";\n  \n  // Create map of people by ID for easy lookup\n  const peopleById = new Map(people.map(p => [p.id, p]));\n  \n  // First export all INDI records\n  people.forEach((person, index) => {\n    gedcomText += `0 @${person.id}@ INDI\\n`;\n    gedcomText += `1 NAME ${person.firstName || \"\"} /${person.lastName || \"\"}/\\n`;\n    if (person.birthDate) {\n      gedcomText += \"1 BIRT\\n2 DATE \" + person.birthDate + \"\\n\";\n    }\n    if (person.deathDate) {\n      gedcomText += \"1 DEAT\\n2 DATE \" + person.deathDate + \"\\n\";\n    }\n  });\n\n  // Then create FAM records based on parent relationships\n  const processedFamilies = new Set();\n  \n  people.forEach(person => {\n    if (person.parents && person.parents.length > 0) {\n      // Create a unique family ID based on parents\n      const familyId = `F${person.parents.sort().join('_')}`;\n      \n      // Only process each family once\n      if (!processedFamilies.has(familyId)) {\n        processedFamilies.add(familyId);\n        \n        gedcomText += `0 @${familyId}@ FAM\\n`;\n        if (person.parents[0]) {\n          gedcomText += `1 HUSB @${person.parents[0]}@\\n`;\n        }\n        if (person.parents[1]) {\n          gedcomText += `1 WIFE @${person.parents[1]}@\\n`;\n        }\n        \n        // Find all children who share these parents\n        people.forEach(potentialChild => {\n          if (potentialChild.parents &&\n              potentialChild.parents.length === person.parents.length &&\n              potentialChild.parents.every(p => person.parents.includes(p))) {\n            gedcomText += `1 CHIL @${potentialChild.id}@\\n`;\n          }\n        });\n      }\n    }\n  });\n\n  gedcomText += \"0 TRLR\\n\";\n  return gedcomText;\n}\n"],"mappings":"AAAA,OAAO,SAASA,YAAYA,CAACC,MAAM,EAAE;EACnC,IAAIC,UAAU,GAAG,wBAAwB;;EAEzC;EACA,MAAMC,UAAU,GAAG,IAAIC,GAAG,CAACH,MAAM,CAACI,GAAG,CAACC,CAAC,IAAI,CAACA,CAAC,CAACC,EAAE,EAAED,CAAC,CAAC,CAAC,CAAC;;EAEtD;EACAL,MAAM,CAACO,OAAO,CAAC,CAACC,MAAM,EAAEC,KAAK,KAAK;IAChCR,UAAU,IAAI,MAAMO,MAAM,CAACF,EAAE,UAAU;IACvCL,UAAU,IAAI,UAAUO,MAAM,CAACE,SAAS,IAAI,EAAE,KAAKF,MAAM,CAACG,QAAQ,IAAI,EAAE,KAAK;IAC7E,IAAIH,MAAM,CAACI,SAAS,EAAE;MACpBX,UAAU,IAAI,iBAAiB,GAAGO,MAAM,CAACI,SAAS,GAAG,IAAI;IAC3D;IACA,IAAIJ,MAAM,CAACK,SAAS,EAAE;MACpBZ,UAAU,IAAI,iBAAiB,GAAGO,MAAM,CAACK,SAAS,GAAG,IAAI;IAC3D;EACF,CAAC,CAAC;;EAEF;EACA,MAAMC,iBAAiB,GAAG,IAAIC,GAAG,CAAC,CAAC;EAEnCf,MAAM,CAACO,OAAO,CAACC,MAAM,IAAI;IACvB,IAAIA,MAAM,CAACQ,OAAO,IAAIR,MAAM,CAACQ,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE;MAC/C;MACA,MAAMC,QAAQ,GAAG,IAAIV,MAAM,CAACQ,OAAO,CAACG,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,EAAE;;MAEtD;MACA,IAAI,CAACN,iBAAiB,CAACO,GAAG,CAACH,QAAQ,CAAC,EAAE;QACpCJ,iBAAiB,CAACQ,GAAG,CAACJ,QAAQ,CAAC;QAE/BjB,UAAU,IAAI,MAAMiB,QAAQ,SAAS;QACrC,IAAIV,MAAM,CAACQ,OAAO,CAAC,CAAC,CAAC,EAAE;UACrBf,UAAU,IAAI,WAAWO,MAAM,CAACQ,OAAO,CAAC,CAAC,CAAC,KAAK;QACjD;QACA,IAAIR,MAAM,CAACQ,OAAO,CAAC,CAAC,CAAC,EAAE;UACrBf,UAAU,IAAI,WAAWO,MAAM,CAACQ,OAAO,CAAC,CAAC,CAAC,KAAK;QACjD;;QAEA;QACAhB,MAAM,CAACO,OAAO,CAACgB,cAAc,IAAI;UAC/B,IAAIA,cAAc,CAACP,OAAO,IACtBO,cAAc,CAACP,OAAO,CAACC,MAAM,KAAKT,MAAM,CAACQ,OAAO,CAACC,MAAM,IACvDM,cAAc,CAACP,OAAO,CAACQ,KAAK,CAACnB,CAAC,IAAIG,MAAM,CAACQ,OAAO,CAACS,QAAQ,CAACpB,CAAC,CAAC,CAAC,EAAE;YACjEJ,UAAU,IAAI,WAAWsB,cAAc,CAACjB,EAAE,KAAK;UACjD;QACF,CAAC,CAAC;MACJ;IACF;EACF,CAAC,CAAC;EAEFL,UAAU,IAAI,UAAU;EACxB,OAAOA,UAAU;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}