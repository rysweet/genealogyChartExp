{"ast":null,"code":"var _jsxFileName = \"/Users/ryan/genealogyChartExp/my-genealogy-app/src/components/GenealogyChart.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from \"react\";\nimport * as d3 from \"d3\";\nimport PersonEditForm from \"./PersonEditForm\";\n\n// Constants\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst RING_WIDTH = 60; // radial width for each generation ring\nconst ARC_PADDING = 0; // gap (in degrees) between arc segments\nconst CENTER_RADIUS = 30; // radius for the center circle\n\n// Font defaults for measuring & layout\nconst DEFAULT_FONT_SIZE = 8;\nconst LINE_SPACING = 10; // radial offset between lines in multi-line wrap\n\nexport default function GenealogyChart({\n  people,\n  maxGenerations,\n  centerPersonId,\n  onUpdatePeople\n}) {\n  _s();\n  const [selectedPersonId, setSelectedPersonId] = useState(null);\n  const svgRef = useRef(null);\n  useEffect(() => {\n    if (!people || people.length === 0) return;\n    drawChart();\n  }, [people, maxGenerations]);\n\n  /** Approximate text width, naive approach */\n  function approximateTextWidth(text, fontSize = DEFAULT_FONT_SIZE) {\n    // Rough average: 0.6 * fontSize per character\n    // You can refine with your actual font metrics\n    const avgCharWidth = fontSize * 0.6;\n    return text.length * avgCharWidth;\n  }\n\n  /**\n   * Splits a string into multiple lines if needed to fit arcLength.\n   * - Naive word-based approach: tries to pack words onto a line until it no longer fits.\n   * - Returns an array of lines (strings).\n   */\n  function wrapTextOnArc(label, arcLength, fontSize = DEFAULT_FONT_SIZE) {\n    // Split by spaces\n    const words = label.split(\" \");\n    const lines = [];\n    let currentLineWords = [];\n    for (let i = 0; i < words.length; i++) {\n      const testLine = currentLineWords.concat(words[i]).join(\" \");\n      const testWidth = approximateTextWidth(testLine, fontSize);\n      if (testWidth <= arcLength) {\n        // It fits, so keep building\n        currentLineWords.push(words[i]);\n      } else {\n        // It doesn't fit, so push the current line and start a new one\n        lines.push(currentLineWords.join(\" \"));\n        currentLineWords = [words[i]];\n      }\n    }\n\n    // Push leftover\n    if (currentLineWords.length) {\n      lines.push(currentLineWords.join(\" \"));\n    }\n    return lines;\n  }\n  function drawChart() {\n    const width = 800;\n    const height = 800;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Clear previous content\n    d3.select(svgRef.current).selectAll(\"*\").remove();\n\n    // Create base SVG\n    const svg = d3.select(svgRef.current).attr(\"width\", width).attr(\"height\", height);\n\n    // Map of id -> person\n    const peopleMap = new Map(people.map(p => [p.id, p]));\n\n    // Build BFS arrays of ancestors\n    const ancestors = [];\n    for (let i = 0; i < maxGenerations; i++) {\n      ancestors[i] = new Array(2 ** i).fill(null);\n    }\n    // Generation 0 => center\n    ancestors[0][0] = centerPersonId;\n\n    // Populate next generations\n    for (let i = 0; i < maxGenerations - 1; i++) {\n      const size = 2 ** i;\n      for (let j = 0; j < size; j++) {\n        const personId = ancestors[i][j];\n        if (!personId) continue;\n        const person = peopleMap.get(personId);\n        if (!person) continue;\n\n        // father => 2*j, mother => 2*j+1\n        if (person.parents && person.parents.length > 0) {\n          ancestors[i + 1][2 * j] = person.parents[0] || null;\n        }\n        if (person.parents && person.parents.length > 1) {\n          ancestors[i + 1][2 * j + 1] = person.parents[1] || null;\n        }\n      }\n    }\n\n    // 1) Draw center circle\n    const centerPerson = peopleMap.get(centerPersonId);\n    svg.append(\"circle\").attr(\"cx\", centerX).attr(\"cy\", centerY).attr(\"r\", CENTER_RADIUS).attr(\"fill\", \"#F6C\").attr(\"stroke\", \"#333\").on(\"click\", () => {\n      setSelectedPersonId(centerPersonId);\n    });\n    svg.append(\"text\").attr(\"x\", centerX).attr(\"y\", centerY + 4).attr(\"text-anchor\", \"middle\").style(\"font-size\", `${DEFAULT_FONT_SIZE}px`).text(centerPerson ? centerPerson.firstName + \" \" + centerPerson.lastName : \"Unknown\");\n\n    // 2) Concentric arcs for each generation\n    for (let i = 1; i < maxGenerations; i++) {\n      const genArray = ancestors[i];\n      const segmentCount = 2 ** i;\n      const arcAngle = 2 * Math.PI / segmentCount - ARC_PADDING * Math.PI / 180;\n\n      // ring boundaries\n      const innerRadius = (i - 1) * RING_WIDTH + CENTER_RADIUS;\n      const outerRadius = i * RING_WIDTH + CENTER_RADIUS;\n      for (let k = 0; k < segmentCount; k++) {\n        const personId = genArray[k];\n        const startAngle = k * (2 * Math.PI / segmentCount);\n        const endAngle = startAngle + arcAngle;\n\n        // Arc generator for the ring slice\n        const arcGenerator = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(startAngle).endAngle(endAngle);\n        if (!personId) {\n          // Blank arc\n          svg.append(\"path\").attr(\"transform\", `translate(${centerX},${centerY})`).attr(\"d\", arcGenerator).attr(\"fill\", \"#eee\").attr(\"stroke\", \"#ccc\");\n          continue;\n        }\n\n        // Draw the arc for this person\n        svg.append(\"path\").attr(\"transform\", `translate(${centerX},${centerY})`).attr(\"d\", arcGenerator).attr(\"fill\", \"#ddd\").attr(\"stroke\", \"#999\").on(\"click\", () => {\n          setSelectedPersonId(personId);\n        });\n\n        // Build the label text\n        const person = peopleMap.get(personId);\n        let label = \"Unknown\";\n        if (person) {\n          label = person.firstName + \" \" + person.lastName + \" (\" + person.birthDate + \" - \" + person.deathDate + \")\";\n        }\n\n        // measure arc length (approx)\n        const midRadius = (innerRadius + outerRadius) / 2;\n        const angleDiff = Math.abs(endAngle - startAngle);\n        const arcLength = angleDiff * midRadius;\n\n        // Attempt multi-line wrap if it won't fit\n        const lines = wrapTextOnArc(label, arcLength, DEFAULT_FONT_SIZE);\n\n        // We'll \"stack\" each line at a different radius offset\n        // so line0 is near midRadius - half*(numLines-1)*lineSpacing\n        // that roughly centers them vertically\n        const numLines = lines.length;\n        const totalHeight = (numLines - 1) * LINE_SPACING;\n        const topMostRadius = midRadius - totalHeight / 2;\n\n        // For each line, create a path at (topMostRadius + lineIndex*LINE_SPACING)\n        lines.forEach((lineText, idx) => {\n          const lineRadius = topMostRadius + idx * LINE_SPACING;\n          // Arc for this line\n          const lineArcGenerator = d3.arc().innerRadius(lineRadius).outerRadius(lineRadius).startAngle(startAngle).endAngle(endAngle);\n          const textPathId = `textPath-${i}-${k}-line${idx}`;\n          svg.append(\"defs\").append(\"path\").attr(\"id\", textPathId).attr(\"transform\", `translate(${centerX},${centerY})`).attr(\"d\", lineArcGenerator());\n\n          // If you'd prefer to center each line horizontally, you can do\n          // a percentage-based approach or a pixel-based offset. We'll do\n          // a simple \"50%\" offset and middle anchor for now.\n          svg.append(\"text\").style(\"font-size\", `${DEFAULT_FONT_SIZE}px`).append(\"textPath\").attr(\"xlink:href\", \"#\" + textPathId).attr(\"startOffset\", \"50%\").style(\"text-anchor\", \"middle\").text(lineText);\n        });\n      }\n    }\n  }\n  const handleEditSave = updatedPerson => {\n    onUpdatePeople(prev => prev.map(p => p.id === updatedPerson.id ? updatedPerson : p));\n    setSelectedPersonId(null);\n  };\n  const handleEditCancel = () => {\n    setSelectedPersonId(null);\n  };\n  const selectedPerson = people.find(p => p.id === selectedPersonId);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: \"relative\"\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"svg\", {\n      ref: svgRef\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 263,\n      columnNumber: 7\n    }, this), selectedPerson && /*#__PURE__*/_jsxDEV(PersonEditForm, {\n      person: selectedPerson,\n      onSave: handleEditSave,\n      onCancel: handleEditCancel\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 265,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 262,\n    columnNumber: 5\n  }, this);\n}\n_s(GenealogyChart, \"HkK2Qgqlq1AU8O8gVdur7h43CwU=\");\n_c = GenealogyChart;\nvar _c;\n$RefreshReg$(_c, \"GenealogyChart\");","map":{"version":3,"names":["React","useState","useRef","useEffect","d3","PersonEditForm","jsxDEV","_jsxDEV","RING_WIDTH","ARC_PADDING","CENTER_RADIUS","DEFAULT_FONT_SIZE","LINE_SPACING","GenealogyChart","people","maxGenerations","centerPersonId","onUpdatePeople","_s","selectedPersonId","setSelectedPersonId","svgRef","length","drawChart","approximateTextWidth","text","fontSize","avgCharWidth","wrapTextOnArc","label","arcLength","words","split","lines","currentLineWords","i","testLine","concat","join","testWidth","push","width","height","centerX","centerY","select","current","selectAll","remove","svg","attr","peopleMap","Map","map","p","id","ancestors","Array","fill","size","j","personId","person","get","parents","centerPerson","append","on","style","firstName","lastName","genArray","segmentCount","arcAngle","Math","PI","innerRadius","outerRadius","k","startAngle","endAngle","arcGenerator","arc","birthDate","deathDate","midRadius","angleDiff","abs","numLines","totalHeight","topMostRadius","forEach","lineText","idx","lineRadius","lineArcGenerator","textPathId","handleEditSave","updatedPerson","prev","handleEditCancel","selectedPerson","find","position","children","ref","fileName","_jsxFileName","lineNumber","columnNumber","onSave","onCancel","_c","$RefreshReg$"],"sources":["/Users/ryan/genealogyChartExp/my-genealogy-app/src/components/GenealogyChart.jsx"],"sourcesContent":["import React, { useState, useRef, useEffect } from \"react\";\nimport * as d3 from \"d3\";\nimport PersonEditForm from \"./PersonEditForm\";\n\n// Constants\nconst RING_WIDTH = 60;    // radial width for each generation ring\nconst ARC_PADDING = 0;    // gap (in degrees) between arc segments\nconst CENTER_RADIUS = 30; // radius for the center circle\n\n// Font defaults for measuring & layout\nconst DEFAULT_FONT_SIZE = 8;\nconst LINE_SPACING = 10; // radial offset between lines in multi-line wrap\n\nexport default function GenealogyChart({\n  people,\n  maxGenerations,\n  centerPersonId,\n  onUpdatePeople\n}) {\n  const [selectedPersonId, setSelectedPersonId] = useState(null);\n  const svgRef = useRef(null);\n\n  useEffect(() => {\n    if (!people || people.length === 0) return;\n    drawChart();\n  }, [people, maxGenerations]);\n\n  /** Approximate text width, naive approach */\n  function approximateTextWidth(text, fontSize = DEFAULT_FONT_SIZE) {\n    // Rough average: 0.6 * fontSize per character\n    // You can refine with your actual font metrics\n    const avgCharWidth = fontSize * 0.6;\n    return text.length * avgCharWidth;\n  }\n\n  /**\n   * Splits a string into multiple lines if needed to fit arcLength.\n   * - Naive word-based approach: tries to pack words onto a line until it no longer fits.\n   * - Returns an array of lines (strings).\n   */\n  function wrapTextOnArc(label, arcLength, fontSize = DEFAULT_FONT_SIZE) {\n    // Split by spaces\n    const words = label.split(\" \");\n    const lines = [];\n    let currentLineWords = [];\n\n    for (let i = 0; i < words.length; i++) {\n      const testLine = currentLineWords.concat(words[i]).join(\" \");\n      const testWidth = approximateTextWidth(testLine, fontSize);\n\n      if (testWidth <= arcLength) {\n        // It fits, so keep building\n        currentLineWords.push(words[i]);\n      } else {\n        // It doesn't fit, so push the current line and start a new one\n        lines.push(currentLineWords.join(\" \"));\n        currentLineWords = [words[i]];\n      }\n    }\n\n    // Push leftover\n    if (currentLineWords.length) {\n      lines.push(currentLineWords.join(\" \"));\n    }\n    return lines;\n  }\n\n  function drawChart() {\n    const width = 800;\n    const height = 800;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Clear previous content\n    d3.select(svgRef.current).selectAll(\"*\").remove();\n\n    // Create base SVG\n    const svg = d3\n      .select(svgRef.current)\n      .attr(\"width\", width)\n      .attr(\"height\", height);\n\n    // Map of id -> person\n    const peopleMap = new Map(people.map((p) => [p.id, p]));\n\n    // Build BFS arrays of ancestors\n    const ancestors = [];\n    for (let i = 0; i < maxGenerations; i++) {\n      ancestors[i] = new Array(2 ** i).fill(null);\n    }\n    // Generation 0 => center\n    ancestors[0][0] = centerPersonId;\n\n    // Populate next generations\n    for (let i = 0; i < maxGenerations - 1; i++) {\n      const size = 2 ** i;\n      for (let j = 0; j < size; j++) {\n        const personId = ancestors[i][j];\n        if (!personId) continue;\n        const person = peopleMap.get(personId);\n        if (!person) continue;\n\n        // father => 2*j, mother => 2*j+1\n        if (person.parents && person.parents.length > 0) {\n          ancestors[i + 1][2 * j] = person.parents[0] || null;\n        }\n        if (person.parents && person.parents.length > 1) {\n          ancestors[i + 1][2 * j + 1] = person.parents[1] || null;\n        }\n      }\n    }\n\n    // 1) Draw center circle\n    const centerPerson = peopleMap.get(centerPersonId);\n    svg\n      .append(\"circle\")\n      .attr(\"cx\", centerX)\n      .attr(\"cy\", centerY)\n      .attr(\"r\", CENTER_RADIUS)\n      .attr(\"fill\", \"#F6C\")\n      .attr(\"stroke\", \"#333\")\n      .on(\"click\", () => {\n        setSelectedPersonId(centerPersonId);\n      });\n\n    svg\n      .append(\"text\")\n      .attr(\"x\", centerX)\n      .attr(\"y\", centerY + 4)\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"font-size\", `${DEFAULT_FONT_SIZE}px`)\n      .text(\n        centerPerson\n          ? centerPerson.firstName + \" \" + centerPerson.lastName\n          : \"Unknown\"\n      );\n\n    // 2) Concentric arcs for each generation\n    for (let i = 1; i < maxGenerations; i++) {\n      const genArray = ancestors[i];\n      const segmentCount = 2 ** i;\n      const arcAngle = (2 * Math.PI) / segmentCount - (ARC_PADDING * Math.PI) / 180;\n\n      // ring boundaries\n      const innerRadius = (i - 1) * RING_WIDTH + CENTER_RADIUS;\n      const outerRadius = i * RING_WIDTH + CENTER_RADIUS;\n\n      for (let k = 0; k < segmentCount; k++) {\n        const personId = genArray[k];\n        const startAngle = k * ((2 * Math.PI) / segmentCount);\n        const endAngle = startAngle + arcAngle;\n\n        // Arc generator for the ring slice\n        const arcGenerator = d3\n          .arc()\n          .innerRadius(innerRadius)\n          .outerRadius(outerRadius)\n          .startAngle(startAngle)\n          .endAngle(endAngle);\n\n        if (!personId) {\n          // Blank arc\n          svg\n            .append(\"path\")\n            .attr(\"transform\", `translate(${centerX},${centerY})`)\n            .attr(\"d\", arcGenerator)\n            .attr(\"fill\", \"#eee\")\n            .attr(\"stroke\", \"#ccc\");\n          continue;\n        }\n\n        // Draw the arc for this person\n        svg\n          .append(\"path\")\n          .attr(\"transform\", `translate(${centerX},${centerY})`)\n          .attr(\"d\", arcGenerator)\n          .attr(\"fill\", \"#ddd\")\n          .attr(\"stroke\", \"#999\")\n          .on(\"click\", () => {\n            setSelectedPersonId(personId);\n          });\n\n        // Build the label text\n        const person = peopleMap.get(personId);\n        let label = \"Unknown\";\n        if (person) {\n          label =\n            person.firstName +\n            \" \" +\n            person.lastName +\n            \" (\" +\n            person.birthDate +\n            \" - \" +\n            person.deathDate +\n            \")\";\n        }\n\n        // measure arc length (approx)\n        const midRadius = (innerRadius + outerRadius) / 2;\n        const angleDiff = Math.abs(endAngle - startAngle);\n        const arcLength = angleDiff * midRadius;\n\n        // Attempt multi-line wrap if it won't fit\n        const lines = wrapTextOnArc(label, arcLength, DEFAULT_FONT_SIZE);\n\n        // We'll \"stack\" each line at a different radius offset\n        // so line0 is near midRadius - half*(numLines-1)*lineSpacing\n        // that roughly centers them vertically\n        const numLines = lines.length;\n        const totalHeight = (numLines - 1) * LINE_SPACING;\n        const topMostRadius = midRadius - totalHeight / 2;\n\n        // For each line, create a path at (topMostRadius + lineIndex*LINE_SPACING)\n        lines.forEach((lineText, idx) => {\n          const lineRadius = topMostRadius + idx * LINE_SPACING;\n          // Arc for this line\n          const lineArcGenerator = d3\n            .arc()\n            .innerRadius(lineRadius)\n            .outerRadius(lineRadius)\n            .startAngle(startAngle)\n            .endAngle(endAngle);\n\n          const textPathId = `textPath-${i}-${k}-line${idx}`;\n          svg\n            .append(\"defs\")\n            .append(\"path\")\n            .attr(\"id\", textPathId)\n            .attr(\"transform\", `translate(${centerX},${centerY})`)\n            .attr(\"d\", lineArcGenerator());\n\n          // If you'd prefer to center each line horizontally, you can do\n          // a percentage-based approach or a pixel-based offset. We'll do\n          // a simple \"50%\" offset and middle anchor for now.\n          svg\n            .append(\"text\")\n            .style(\"font-size\", `${DEFAULT_FONT_SIZE}px`)\n            .append(\"textPath\")\n            .attr(\"xlink:href\", \"#\" + textPathId)\n            .attr(\"startOffset\", \"50%\")\n            .style(\"text-anchor\", \"middle\")\n            .text(lineText);\n        });\n      }\n    }\n  }\n\n  const handleEditSave = (updatedPerson) => {\n    onUpdatePeople((prev) =>\n      prev.map((p) => (p.id === updatedPerson.id ? updatedPerson : p))\n    );\n    setSelectedPersonId(null);\n  };\n\n  const handleEditCancel = () => {\n    setSelectedPersonId(null);\n  };\n\n  const selectedPerson = people.find((p) => p.id === selectedPersonId);\n\n  return (\n    <div style={{ position: \"relative\" }}>\n      <svg ref={svgRef}></svg>\n      {selectedPerson && (\n        <PersonEditForm\n          person={selectedPerson}\n          onSave={handleEditSave}\n          onCancel={handleEditCancel}\n        />\n      )}\n    </div>\n  );\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}