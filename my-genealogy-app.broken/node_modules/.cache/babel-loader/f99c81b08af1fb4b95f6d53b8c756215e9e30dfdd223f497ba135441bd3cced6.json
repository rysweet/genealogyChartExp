{"ast":null,"code":"export async function importGedcomFile(file) {\n  const text = await file.text();\n  // We'll store people in an object: peopleById[\"@I1@\"] = {...}\n  // We'll store families in an object: familiesById[\"@F1@\"] = {husb, wife, children: []}\n\n  const peopleById = {};\n  const familiesById = {};\n  let currentRecord = null;\n  let currentType = null;\n  const lines = text.split(/\\\\r?\\\\n/);\n  function startIndividualRecord(id) {\n    // push old record if it was an INDI or FAM\n    finishRecord();\n    currentRecord = {\n      id,\n      firstName: \"\",\n      lastName: \"\",\n      birthDate: \"\",\n      deathDate: \"\",\n      parents: []\n    };\n    currentType = \"INDI\";\n  }\n  function startFamilyRecord(id) {\n    finishRecord();\n    currentRecord = {\n      id,\n      husb: null,\n      wife: null,\n      children: []\n    };\n    currentType = \"FAM\";\n  }\n\n  // finalize record\n  function finishRecord() {\n    if (!currentRecord || !currentType) return;\n    if (currentType === \"INDI\") {\n      peopleById[currentRecord.id] = currentRecord;\n    } else if (currentType === \"FAM\") {\n      familiesById[currentRecord.id] = currentRecord;\n    }\n    currentRecord = null;\n    currentType = null;\n  }\n\n  // parse each line\n  lines.forEach(line => {\n    // e.g. \"0 @I1@ INDI\"\n    // e.g. \"1 NAME John /Doe/\"\n    // e.g. \"1 BIRT\"\n    // e.g. \"2 DATE 1 JAN 1900\"\n    // e.g. \"1 FAMS @F1@\"\n    // e.g. \"1 FAMC @F1@\"\n    // e.g. \"1 HUSB @I2@\"\n    // e.g. \"1 WIFE @I3@\"\n    // e.g. \"1 CHIL @I1@\"\n\n    const parts = line.trim().split(\" \");\n    if (parts.length < 2) return;\n    const level = parts[0];\n    const tagOrId = parts[1];\n    if (level === \"0\" && tagOrId.startsWith(\"@\") && parts.length >= 3) {\n      // starting a new record\n      const maybeType = parts[2];\n      if (maybeType === \"INDI\") {\n        startIndividualRecord(tagOrId);\n      } else if (maybeType === \"FAM\") {\n        startFamilyRecord(tagOrId);\n      } else {\n        // finalize old record\n        finishRecord();\n      }\n    } else if (currentType === \"INDI\") {\n      // handle lines inside an INDI\n      const rest = line.trim().substring(2).trim(); // skip \"1 \" or \"2 \"\n      if (rest.startsWith(\"NAME\")) {\n        // e.g. \"NAME John /Doe/\"\n        let nameVal = rest.replace(\"NAME \", \"\").trim();\n        // quick parse: \"John /Doe/\"\n        const nameParts = nameVal.split(\"/\");\n        if (nameParts.length >= 2) {\n          const firstName = nameParts[0].trim();\n          const lastName = nameParts[1].trim();\n          currentRecord.firstName = firstName;\n          currentRecord.lastName = lastName;\n        } else {\n          currentRecord.firstName = nameVal;\n        }\n      } else if (rest.startsWith(\"GIVN\")) {\n        currentRecord.firstName = rest.replace(\"GIVN \", \"\").trim();\n      } else if (rest.startsWith(\"SURN\")) {\n        currentRecord.lastName = rest.replace(\"SURN \", \"\").trim();\n      } else if (rest.startsWith(\"DATE\") && rest.includes(\"BIRT\")) {\n        // naive\n        currentRecord.birthDate = rest.replace(\"DATE \", \"\").replace(\"BIRT\", \"\").trim();\n      } else if (rest.startsWith(\"DATE\") && rest.includes(\"DEAT\")) {\n        // naive\n        currentRecord.deathDate = rest.replace(\"DATE \", \"\").replace(\"DEAT\", \"\").trim();\n      } else if (rest.startsWith(\"BIRT\")) {\n        // next lines might have date\n      } else if (rest.startsWith(\"DEAT\")) {\n        // next lines might have date\n      }\n    } else if (currentType === \"FAM\") {\n      // lines inside a FAM\n      const rest = line.trim().substring(2).trim();\n      // \"HUSB @I2@\"\n      // \"WIFE @I3@\"\n      // \"CHIL @I1@\"\n      if (rest.startsWith(\"HUSB\")) {\n        const tokens = rest.split(\" \");\n        if (tokens.length >= 2) {\n          currentRecord.husb = tokens[1];\n        }\n      } else if (rest.startsWith(\"WIFE\")) {\n        const tokens = rest.split(\" \");\n        if (tokens.length >= 2) {\n          currentRecord.wife = tokens[1];\n        }\n      } else if (rest.startsWith(\"CHIL\")) {\n        const tokens = rest.split(\" \");\n        if (tokens.length >= 2) {\n          currentRecord.children.push(tokens[1]);\n        }\n      }\n    }\n  });\n\n  // finalize last record\n  finishRecord();\n\n  // second pass: for each family, assign father/mother to children's parents\n  Object.values(familiesById).forEach(fam => {\n    const father = fam.husb;\n    const mother = fam.wife;\n    const kids = fam.children || [];\n    kids.forEach(kidId => {\n      const kid = peopleById[kidId];\n      if (kid) {\n        kid.parents = [];\n        if (father) kid.parents.push(father);\n        if (mother) kid.parents.push(mother);\n      }\n    });\n  });\n\n  // final array\n  const peopleArr = Object.values(peopleById);\n  return peopleArr;\n}","map":{"version":3,"names":["importGedcomFile","file","text","peopleById","familiesById","currentRecord","currentType","lines","split","startIndividualRecord","id","finishRecord","firstName","lastName","birthDate","deathDate","parents","startFamilyRecord","husb","wife","children","forEach","line","parts","trim","length","level","tagOrId","startsWith","maybeType","rest","substring","nameVal","replace","nameParts","includes","tokens","push","Object","values","fam","father","mother","kids","kidId","kid","peopleArr"],"sources":["/Users/ryan/genealogyChartExp/my-genealogy-app/src/gedcom/importGedcom.js"],"sourcesContent":["export async function importGedcomFile(file) {\n  const text = await file.text();\n  // We'll store people in an object: peopleById[\"@I1@\"] = {...}\n  // We'll store families in an object: familiesById[\"@F1@\"] = {husb, wife, children: []}\n\n  const peopleById = {};\n  const familiesById = {};\n  let currentRecord = null;\n  let currentType = null;\n\n  const lines = text.split(/\\\\r?\\\\n/);\n\n  function startIndividualRecord(id) {\n    // push old record if it was an INDI or FAM\n    finishRecord();\n    currentRecord = { id, firstName: \"\", lastName: \"\", birthDate: \"\", deathDate: \"\", parents: [] };\n    currentType = \"INDI\";\n  }\n\n  function startFamilyRecord(id) {\n    finishRecord();\n    currentRecord = { id, husb: null, wife: null, children: [] };\n    currentType = \"FAM\";\n  }\n\n  // finalize record\n  function finishRecord() {\n    if (!currentRecord || !currentType) return;\n    if (currentType === \"INDI\") {\n      peopleById[currentRecord.id] = currentRecord;\n    } else if (currentType === \"FAM\") {\n      familiesById[currentRecord.id] = currentRecord;\n    }\n    currentRecord = null;\n    currentType = null;\n  }\n\n  // parse each line\n  lines.forEach((line) => {\n    // e.g. \"0 @I1@ INDI\"\n    // e.g. \"1 NAME John /Doe/\"\n    // e.g. \"1 BIRT\"\n    // e.g. \"2 DATE 1 JAN 1900\"\n    // e.g. \"1 FAMS @F1@\"\n    // e.g. \"1 FAMC @F1@\"\n    // e.g. \"1 HUSB @I2@\"\n    // e.g. \"1 WIFE @I3@\"\n    // e.g. \"1 CHIL @I1@\"\n\n    const parts = line.trim().split(\" \");\n    if (parts.length < 2) return;\n    const level = parts[0];\n    const tagOrId = parts[1];\n\n    if (level === \"0\" && tagOrId.startsWith(\"@\") && parts.length >= 3) {\n      // starting a new record\n      const maybeType = parts[2];\n      if (maybeType === \"INDI\") {\n        startIndividualRecord(tagOrId);\n      } else if (maybeType === \"FAM\") {\n        startFamilyRecord(tagOrId);\n      } else {\n        // finalize old record\n        finishRecord();\n      }\n    } else if (currentType === \"INDI\") {\n      // handle lines inside an INDI\n      const rest = line.trim().substring(2).trim(); // skip \"1 \" or \"2 \"\n      if (rest.startsWith(\"NAME\")) {\n        // e.g. \"NAME John /Doe/\"\n        let nameVal = rest.replace(\"NAME \", \"\").trim();\n        // quick parse: \"John /Doe/\"\n        const nameParts = nameVal.split(\"/\");\n        if (nameParts.length >= 2) {\n          const firstName = nameParts[0].trim();\n          const lastName = nameParts[1].trim();\n          currentRecord.firstName = firstName;\n          currentRecord.lastName = lastName;\n        } else {\n          currentRecord.firstName = nameVal;\n        }\n      } else if (rest.startsWith(\"GIVN\")) {\n        currentRecord.firstName = rest.replace(\"GIVN \", \"\").trim();\n      } else if (rest.startsWith(\"SURN\")) {\n        currentRecord.lastName = rest.replace(\"SURN \", \"\").trim();\n      } else if (rest.startsWith(\"DATE\") && rest.includes(\"BIRT\")) {\n        // naive\n        currentRecord.birthDate = rest.replace(\"DATE \", \"\").replace(\"BIRT\", \"\").trim();\n      } else if (rest.startsWith(\"DATE\") && rest.includes(\"DEAT\")) {\n        // naive\n        currentRecord.deathDate = rest.replace(\"DATE \", \"\").replace(\"DEAT\", \"\").trim();\n      } else if (rest.startsWith(\"BIRT\")) {\n        // next lines might have date\n      } else if (rest.startsWith(\"DEAT\")) {\n        // next lines might have date\n      }\n    } else if (currentType === \"FAM\") {\n      // lines inside a FAM\n      const rest = line.trim().substring(2).trim();\n      // \"HUSB @I2@\"\n      // \"WIFE @I3@\"\n      // \"CHIL @I1@\"\n      if (rest.startsWith(\"HUSB\")) {\n        const tokens = rest.split(\" \");\n        if (tokens.length >= 2) {\n          currentRecord.husb = tokens[1];\n        }\n      } else if (rest.startsWith(\"WIFE\")) {\n        const tokens = rest.split(\" \");\n        if (tokens.length >= 2) {\n          currentRecord.wife = tokens[1];\n        }\n      } else if (rest.startsWith(\"CHIL\")) {\n        const tokens = rest.split(\" \");\n        if (tokens.length >= 2) {\n          currentRecord.children.push(tokens[1]);\n        }\n      }\n    }\n  });\n\n  // finalize last record\n  finishRecord();\n\n  // second pass: for each family, assign father/mother to children's parents\n  Object.values(familiesById).forEach((fam) => {\n    const father = fam.husb;\n    const mother = fam.wife;\n    const kids = fam.children || [];\n    kids.forEach((kidId) => {\n      const kid = peopleById[kidId];\n      if (kid) {\n        kid.parents = [];\n        if (father) kid.parents.push(father);\n        if (mother) kid.parents.push(mother);\n      }\n    });\n  });\n\n  // final array\n  const peopleArr = Object.values(peopleById);\n\n  return peopleArr;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}